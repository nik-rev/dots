//! `dots` is a cozy dotfiles manager

use clap::Parser;
use etcetera::BaseStrategy as _;
use eyre::{Context as _, ContextCompat as _, Result, bail, eyre};
use handlebars::Handlebars;
use interpolator::Formattable;
use itertools::Itertools as _;
use serde::{Deserialize, Serialize};
use simply_colored::*;
use std::collections::{BTreeMap, HashMap};
use std::env::current_dir;
use std::fs::canonicalize;
use std::io::Write as _;
use std::path::PathBuf;
use std::str::FromStr;
use std::{env, fs, path::Path};
use tap::Pipe as _;

/// Marker to use in files to add extra info about them
const MARKER: &str = "@dots ";
/// Name of the config file for `dots` to search for
const CONFIG_FILE_NAME: &str = "dots.toml";

mod stdx;

use log::Level;
use walkdir::WalkDir;

/// Configuration for `dots`
#[derive(Serialize, Deserialize)]
struct Config {
    /// The config directory, from which all files will be written to `.config`
    config_dir: PathBuf,
    /// A list of links
    ///
    /// File located at the link will be fetched into the appropriate location
    link: Vec<Link>,
}

/// A link representing a file to be fetched
#[derive(Serialize, Deserialize)]
struct Link {
    /// URL to the link, e.g. `https://raw.githubusercontent.com/catppuccin/nushell/05987d258cb765a881ee1f2f2b65276c8b379658/themes/catppuccin_mocha.nu`
    url: String,
    /// Path where to write the file to in the `config` directory,
    /// e.g. `nushell/catppuccin.nu` writes to `config/nushell/catppuccin.nu` if `config` in `Config` is `"config"`
    path: PathBuf,
    /// Expected hash of the file. This can be supplied for security purposes
    sha256: Option<String>,
    /// A marker to add, like `"--path '{config}/gitui/theme.ron'"`
    marker: Option<String>,
}

/// Arguments that the marker takes
#[derive(Parser)]
struct MarkerArgs {
    /// Write file to this path
    #[arg(long)]
    path: Option<String>,
}

impl FromStr for MarkerArgs {
    type Err = eyre::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        shellwords::split(s)?
            .pipe(MarkerArgs::try_parse_from)?
            .pipe(Ok)
    }
}

/// Prepend a comment header describing that this file is generated
fn prepend_comment_header(s: &str, url: &str, ext: &Path) -> String {
    let marker = s
        .lines()
        .next()
        .filter(|line| line.contains(MARKER))
        .map(|line| format!("{line}\n"))
        .unwrap_or_default();
    let contents = if let Some(first_line) = s.lines().next()
        && first_line.contains(MARKER)
    {
        s.lines().skip(1).collect::<Vec<_>>().join("\n")
    } else {
        s.to_string()
    };

    let header = [
        format!("@generated by `{MARKER}`"),
        "Do not edit by hand.".to_string(),
        String::new(),
        format!("downloaded from: {url}"),
    ];
    header
        .into_iter()
        .fold(String::new(), |contents, line| {
            format!("{contents}{}\n", commented::comment(line, ext))
        })
        .pipe(|comment| format!("{marker}{comment}{contents}"))
}

fn main() -> Result<()> {
    env_logger::Builder::new()
        .filter_level(log::LevelFilter::Info)
        .format(|buf, record| {
            let color = match record.level() {
                Level::Error => RED,
                Level::Warn => YELLOW,
                Level::Info => GREEN,
                Level::Debug => BLUE,
                Level::Trace => CYAN,
            };
            let level = record.level();
            let message = record.args();

            writeln!(buf, "{BLACK}[{color}{level}{BLACK}]{RESET} {message}",)
        })
        .init();

    let _ = color_eyre::install();

    let root = current_dir().context("failed to obtain current directory")?;
    let config = root
        .join(CONFIG_FILE_NAME)
        .pipe(fs::read_to_string)
        .with_context(|| eyre!("failed to read config file {CONFIG_FILE_NAME}"))?
        .pipe(|x| toml::de::from_str::<Config>(&x))
        .context("failed to parse config file")?;

    let home = env::home_dir().context("failed to obtain home directory")?;

    let root_configs = root.join(config.config_dir);

    config
        .link
        .iter()
        // download each link
        .map(
            |Link {
                 url,
                 path,
                 sha256,
                 marker,
             }| {
                let contents = ureq::get(url).call()?.body_mut().read_to_string()?;
                let actual_sha256 = sha256::digest(&contents);

                if let Some(sha256) = sha256
                    && actual_sha256 != *sha256
                {
                    let mismatch = format!("link       {BLUE}{url}{RESET}");
                    let actual = format!("actual     {CYAN}{actual_sha256}{RESET}");
                    let expected = format!("expected   {CYAN}{sha256}{RESET}");
                    bail!("hash mismatch\n  {mismatch}\n  {actual}\n  {expected}");
                }
                let path = root_configs.join(path);

                // add the marker if necessary
                let marker = marker.as_ref().map_or(String::new(), |v| {
                    format!("{MARKER}{v}").pipe(|it| commented::comment(it, &path)) + "\n"
                });
                let contents = format!("{marker}{contents}");
                stdx::remove_file(&path)
                    .with_context(|| eyre!("failed to remove file: {}", path.display()))?;

                let dir = path
                    .parent()
                    .with_context(|| eyre!("failed to obtain parent of {}", path.display()))?;
                fs::create_dir_all(dir)
                    .with_context(|| eyre!("failed to create directory for {}", dir.display()))?;

                fs::write(&path, prepend_comment_header(&contents, url, &path))
                    .with_context(|| eyre!("failed to write to {}", path.display()))?;

                log::info!(
                    "{CYAN}downloaded{RESET}\n  {BLUE}{url}{RESET} {BLACK}\n  ->{RESET}  {}",
                    path.display()
                );

                Ok::<_, eyre::Error>(())
            },
        )
        // we want to report all errors instead of stopping on
        // the first one
        .partition::<Vec<_>, _>(Result::is_ok)
        .pipe(|(_, errors)| {
            for error in &errors {
                log::error!(
                    "{}",
                    error
                        .as_ref()
                        .expect_err("can only get here if `Result::is_err`")
                );
            }
            if errors.is_empty() {
                Err(eyre!("encountered errors when downloading links"))
            } else {
                Ok(())
            }
        })?;

    #[cfg(target_os = "windows")]
    let config = home.join("AppData");
    #[cfg(not(target_os = "windows"))]
    let config = home.join(".config");

    WalkDir::new(&root_configs)
        .into_iter()
        .flatten()
        .filter(|dir_entry| dir_entry.file_type().is_file())
        .try_for_each(|file| {
            let old_location = file.path();

            let file_contents = fs::read_to_string(old_location)
                .with_context(|| eyre!("failed to read path {}", old_location.display()))?;

            let relative_location =
                old_location.strip_prefix(&root_configs).with_context(|| {
                    eyre!(
                        "failed to strip prefix {} from {}",
                        root_configs.display(),
                        old_location.display()
                    )
                })?;
            let (file_contents, new_location) = if let Some(first_line) =
                file_contents.lines().next()
                && let Some(marker_start_pos) = first_line.find(MARKER)
                && let Some(marker_args) = first_line.get(marker_start_pos + MARKER.len()..)
                && let Ok(args) = marker_args.parse::<MarkerArgs>()
                && let Some(path) = args.path
            {
                let strat = etcetera::choose_base_strategy()
                    .with_context(|| eyre!("failed to obtain base strategy"))?;
                (
                    // remove the first line which contains the `@dotfilers`
                    file_contents.lines().skip(1).collect_vec().join(","),
                    interpolator::format(
                        &path,
                        &[
                            (
                                "config",
                                strat
                                    .config_dir()
                                    .to_string_lossy()
                                    .to_string()
                                    .pipe_ref(Formattable::display),
                            ),
                            (
                                "home",
                                strat
                                    .home_dir()
                                    .to_string_lossy()
                                    .to_string()
                                    .pipe_ref(Formattable::display),
                            ),
                        ]
                        .pipe(HashMap::from),
                    )
                    .context("failed to parse marker")?
                    .pipe(PathBuf::from),
                )
            } else {
                (file_contents, config.join(relative_location))
            };

            let old_relative_to_cwd_canon = canonicalize(old_location)
                .with_context(|| eyre!("failed to canonicalize {}", old_location.display()))?;
            let old_relative_to_cwd = old_relative_to_cwd_canon
                .strip_prefix(&root)
                .with_context(|| {
                    eyre!(
                        "failed to strip prefix {} from {}",
                        root.display(),
                        old_relative_to_cwd_canon.display()
                    )
                })?
                .display();

            // 1. Remove the old file
            match fs::remove_file(&new_location) {
                Err(err) if err.kind() == std::io::ErrorKind::NotFound => (),
                Err(err) => {
                    panic!("{err}");
                }
                Ok(()) => {
                    log::warn!("{RED}removed{RESET} {old_relative_to_cwd}");
                }
            }

            let dir = new_location
                .parent()
                .with_context(|| eyre!("failed to obtain "))?;

            // 2. Parent directory of existing file might not exit
            //
            //    We don't want to symlink directories themselves,
            //    because they might contain data we don't want in
            //    our dotfiles.
            fs::create_dir_all(dir).with_context(|| eyre!("failed to create {}", dir.display()))?;

            let mut handlebars = Handlebars::new();
            handlebars
                .register_template_string("t1", file_contents)
                .with_context(|| {
                    eyre!("failed to parse template for {}", new_location.display())
                })?;

            let contents = handlebars
                .render("t1", &BTreeMap::<u8, u8>::new())
                .with_context(|| {
                    eyre!("failed to render template for {}", new_location.display())
                })?;

            fs::write(&new_location, contents)
                .with_context(|| eyre!("failed to write to {}", new_location.display()))?;

            log::info!(
                "{CYAN}symlinked{RESET} \n  {} {BLACK}\n  ->  {RESET}{}",
                old_relative_to_cwd,
                new_location
                    .strip_prefix(&home)
                    .map_or(new_location.clone(), |location| format!(
                        "~{}{}",
                        std::path::MAIN_SEPARATOR,
                        location.display()
                    )
                    .pipe(PathBuf::from))
                    .display()
            );

            Ok::<_, eyre::Error>(())
        })?;

    Ok(())
}
