//! handle world

use std::collections::BTreeMap;
use std::path::PathBuf;

use crate::config::GITHUB;
use crate::output_path::OutputPath;
use crate::{World, config::Marker};

use eyre::{Context as _, Error, Result, bail, eyre};
use handlebars::Handlebars;
use itertools::Itertools as _;
use simply_colored::*;
use tap::Pipe as _;

/// Write contents to the path
#[derive(Debug)]
pub struct WritePath {
    /// Path to write
    pub path: PathBuf,
    /// What to write
    pub contents: String,
}

/// Handle the World.
pub fn handle_world(world: World) -> Result<Vec<WritePath>, Vec<Error>> {
    let mut errors = vec![];

    let links = world
        .links
        .into_iter()
        .map(
            |crate::world::Link {
                 contents,
                 path,
                 sha256,
                 marker,
                 url,
             }| {
                let actual_sha256 = sha256::digest(&contents);

                if let Some(expected_sha256) = sha256
                    && actual_sha256 != *expected_sha256
                {
                    let mismatch = format!("link       {BLUE}{url}{RESET}");
                    let actual = format!("actual     {CYAN}{actual_sha256}{RESET}");
                    let expected = format!("expected   {CYAN}{expected_sha256}{RESET}");
                    bail!("hash mismatch\n  {mismatch}\n  {actual}\n  {expected}");
                }

                // download the link's contents to *this* path
                let path = world.root.join(path);

                // add the marker if necessary
                let marker = marker.as_ref().map_or(String::new(), |marker_args| {
                    format!("{}{marker_args}", Marker::MARKER)
                        .pipe(|marker| commented::comment(marker, &path))
                        + "\n"
                });

                let file_contents = format!("{marker}{contents}");

                let marker = file_contents
                    .lines()
                    .next()
                    .filter(|line| line.contains(Marker::MARKER))
                    .map(|line| format!("{line}\n"))
                    .unwrap_or_default();

                let contents = if let Some(first_line) = file_contents.lines().next()
                    && first_line.contains(Marker::MARKER)
                {
                    file_contents.lines().skip(1).collect::<Vec<_>>().join("\n")
                } else {
                    file_contents.to_string()
                };

                let generated_notice = [
                    format!("@generated by `{}` <{GITHUB}>", Marker::MARKER),
                    "Do not edit by hand.".to_string(),
                    String::new(),
                    format!("downloaded from: {url}"),
                ]
                .into_iter()
                .fold(String::new(), |previous_lines, line| {
                    format!("{previous_lines}{}\n", commented::comment(line, &path))
                });

                let contents = format!("{marker}{generated_notice}{contents}");

                Ok(WritePath { path, contents })
            },
        )
        .partition_result::<Vec<_>, Vec<_>, _, _>()
        .pipe(|(oks, errs)| {
            errors.extend(errs);
            oks
        });

    let files = world
        .files
        .into_iter()
        .map(
            |crate::world::File {
                 old_location,
                 contents,
                 output,
                 input,
             }| {
                let relative_location = old_location
                    .strip_prefix(&world.root)?
                    .strip_prefix(&input)?;

                let (file_contents, new_location) = if let Some(first_line) =
                    contents.lines().next()
                    && let Some(marker_start_pos) = first_line.find(Marker::MARKER)
                    && let Some(marker_args) =
                        first_line.get(marker_start_pos + Marker::MARKER.len()..)
                    && let Ok(args) = marker_args.parse::<Marker>()
                    && let Some(path) = args.path
                {
                    (
                        // remove the first line which contains the `@dotfilers`
                        contents.lines().skip(1).collect_vec().join(","),
                        path,
                    )
                } else {
                    (
                        contents,
                        output
                            .as_ref()
                            .join(relative_location)
                            .pipe(OutputPath::new),
                    )
                };

                let mut handlebars = Handlebars::new();
                handlebars
                    .register_template_string("t1", file_contents)
                    .with_context(|| eyre!("failed to parse template for {new_location}"))?;

                let contents = handlebars
                    .render("t1", &BTreeMap::<u8, u8>::new())
                    .with_context(|| eyre!("failed to render template for {new_location}"))?;

                Ok::<_, Error>(WritePath {
                    path: new_location.into_inner(),
                    contents,
                })
            },
        )
        .partition_result::<Vec<_>, Vec<_>, _, _>()
        .pipe(|(oks, errs)| {
            errors.extend(errs);
            oks
        });

    if !errors.is_empty() {
        return Err(errors);
    }

    Ok(links.into_iter().chain(files).collect())
}
